/**
 * File:	modules/IscsiServer.ycp
 * Package:	Configuration of iscsi-server
 * Summary:	IscsiServer settings, input and output functions
 * Authors:	Michal Zugec <mzugec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of iscsi-server.
 * Input and output routines.
 */

{

module "IscsiServer";
textdomain "iscsi-server";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Service";
import "Package";
import "Popup";
import "SuSEFirewall";
import "Confirm";
import "IscsiServerFunctions";

boolean serviceStatus = false;

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

// Settings: Define all variables needed for configuration of iscsi-server
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//   boolean additional_parameter = true;

// read configuration file /etc/ietd.conf
boolean readConfig(){
 IscsiServerFunctions::parseConfig( (map<string, any>)SCR::Read(.etc.ietd.all) );
 return true;
}


// write configuration file /etc/ietd.conf
boolean writeConfig(){
 // prepare map, because perl->ycp lost information about data types (integers in this case)
 map <string, any> config_file = IscsiServerFunctions::writeConfig();
 config_file["type"]=tointeger(config_file["type"]:"1");
 config_file["file"]=tointeger(config_file["file"]:"1");
 list <map<string, any> > value = [];
 foreach(map<string, any> row, config_file["value"]:[], {
  row["type"]=tointeger(row["type"]:"1");
  row["file"]=tointeger(row["file"]:"1");
  value = add(value, row);
 });

 config_file["value"] = value;
 y2milestone("%1", config_file);
 // write it
 SCR::Write(.etc.ietd.all, config_file);
 SCR::Write(.etc.ietd, nil);
 return true;
}

// test if required package ("iscsitarget") is installed
boolean installed_packages(){
 boolean ret = false;
  if( !Package::InstallMsg( "iscsitarget",
            _("<p>To configure the iSCSI target, the <b>%1</b> package must be installed.</p>") +
            _("<p>Install it now?</p>")) )
        {
        Popup::Error( Message::CannotContinueWithoutPackagesInstalled() );
    } else ret = true;

 return ret;
}

// check status of iscsitarget service
// if not enabled, start it manually
boolean getServiceStatus(){
 boolean ret = true;
 if (Service::Status("iscsitarget") == 0) serviceStatus=true;
y2internal("Service status = %1", serviceStatus);
 if (!serviceStatus) Service::Start("iscsitarget");
 return ret;
}

// set service status
boolean setServiceStatus(){
 boolean ret = true;
 if (!serviceStatus) Service::Stop("iscsitarget");
 return ret;
}

// #157643 - reload server
boolean reloadServer(){
// ask user whether reload or restart server
if (Popup::YesNo(_(
"If changes have been made, the iSCSI target is not able \n"
"to reload current configuration. It can only restart.\n"
"When restarting, all sessions are aborted.\n"
"Restart the iscsitarget service?"
))) Service::Restart("iscsitarget");
 else {
	// get changes from perl module
	 map<string, any> changes = IscsiServerFunctions::getChanges();
	 list<string> connected = IscsiServerFunctions::getConnected();
	// plus add there all targets except with active sessions (it means delete and create as new each target)
         foreach(string key,any value, IscsiServerFunctions::getTargets(), {
	 if ((!contains(connected, key))&&(!contains(changes["add"]:[], key))&&(!contains(changes["del"]:[], key))){
	   changes["del"] = add (changes["del"]:[], key);
	   changes["add"] = add (changes["add"]:[], key);
           y2milestone("modified key %1", key);
	  }
         });

	// delete targets
	 foreach(string row, changes["del"]:[], {
	  y2internal("to delete %1", row);
	  string  target=((map<string, any>)SCR::Execute(.target.bash_output,
		// get TID number for target
		"cat /proc/net/iet/volume|grep $TARGET", $["TARGET":row]))["stdout"]:"" ;
	  string to_delete = splitstring( splitstring(target, " ")[0]:"", ":")[1]:"";
	  y2internal("to delete %1", to_delete);
	// delete record with that TID
	  SCR::Execute(.target.bash_output, "ietadm --op delete --tid=$TID", $["TID":to_delete]);
	 });

	// add a new target
	 foreach(string row, changes["add"]:[], {
          y2internal("to add %1", row);
	// create new target
	 SCR::Execute(.target.bash_output, "ietadm --op new --tid=0 --params Name=$NAME", $["NAME":row]);
          string  target=((map<string, any>)SCR::Execute(.target.bash_output,
                "cat /proc/net/iet/volume|grep $TARGET", $["TARGET":row]))["stdout"]:"" ;
	// get TID of that target
          string to_add = splitstring( splitstring(target, " ")[0]:"", ":")[1]:"";
	 list<string> lun = [];
	 list <string> secret = [];
	// add authentication to target
	   foreach( map<string, any> conf_row, (list<map<string, any> >) IscsiServerFunctions::getConfig()[row]:[], {
	    switch (conf_row["KEY"]:""){
		case("Lun") : lun = splitstring(conf_row["VALUE"]:"", " ");
				break;
		case("IncomingUser") :  secret = splitstring(conf_row["VALUE"]:"", " ");
	y2internal("params %1 %2 %3", to_add, secret[0]:"", secret[1]:"");
					SCR::Execute(.target.bash_output, "ietadm --op new --tid=$TID --user --params=IncomingUser=$US,Password=$PASS", $["TID":to_add, "US":secret[0]:"", "PASS":secret[1]:""]);
				break;
		case("OutgoingUser") :  secret = splitstring(conf_row["VALUE"]:"", " ");
					SCR::Execute(.target.bash_output, "ietadm --op new --tid=$TID --user --params=OutgoingUser=$US,Password=$PASS", $["TID":to_add, "US":secret[0]:"", "PASS":secret[1]:""]);
				break;
	   }
	   });
	 string lun_num = lun[0]:"";
	 string lun_path = splitstring(lun[1]:"", ",")[0]:"";
	// add LUN for target
	string command = sformat("ietadm --op new --tid=%1 --lun=%2 --params %3", to_add, lun_num, lun_path);
	y2internal("command: %1", command);
	SCR::Execute(.target.bash_output, command, $[]);
	 y2internal("lun %1,%2", lun_num, lun_path);
	 });
      }

 return true;
}


/**
 * Read all iscsi-server settings
 * @return true on success
 */
global boolean Read() {

    /* IscsiServer read dialog caption */
    string caption = _("Initializing iSCSI Target Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the database"),
	    /* Progress stage 2/3 */
	    _("Read the previous settings"),
	    /* Progress stage 3/3 */
	    _("Detect the devices")
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress step 2/3 */
	    _("Reading the previous settings..."),
	    /* Progress step 3/3 */
	    _("Detecting the devices..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // check if user is root
    if(!Confirm::MustBeRoot()) return false;
    Progress::NextStage();
    // check if required packages ("iscsitarget") are installed
    if(!installed_packages()) return false;
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStep();
    // get status of iscsitarget init script
    if(!getServiceStatus()) return false;
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage();
    // read configuration (/etc/ietd.conf)
    if(!readConfig()) {
	 Report::Error(Message::CannotReadCurrentSettings());
	 return false;
	}
    sleep(sl);

    // detect devices
        Progress::set(false);
        SuSEFirewall::Read();
        Progress::set(true);

    Progress::NextStage();
    /* Error message */
    if(false) return false;
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all iscsi-server settings
 * @return true on success
 */
global boolean Write() {

    /* IscsiServer write dialog caption */
    string caption = _("Saving iSCSI Target Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );


        Progress::set(false);
        SuSEFirewall::Write();
        Progress::set(true);

    Progress::NextStage();
    // write configuration (/etc/ietd.conf)
    if(!writeConfig()) Report::Error (_("Cannot write settings."));
    sleep(sl);


    if(Abort()) return false;
    Progress::NextStage ();
    //  ask user whether reload or restart server and do it
    if(!reloadServer()) return false;
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage();
    sleep(sl);
    // set iscsitarget initscript status
    if(!setServiceStatus()) return false;
    return true;
}

/**
 * Get all iscsi-server settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the iscsi-server settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}


// get/set service accessors for CWMService component
global boolean GetStartService() {
 return Service::Enabled("iscsitarget");
}

global void SetStartService(boolean status) {
 y2milestone("Set service status %1", status);
 if (status == true) Service::Enable("iscsitarget");
        else Service::Disable("iscsitarget");
}


/* EOF */
}
