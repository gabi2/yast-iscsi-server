/**
 * File:	modules/IscsiServer.ycp
 * Package:	Configuration of iscsi-server
 * Summary:	IscsiServer settings, input and output functions
 * Authors:	Michal Zugec <mzugec@suse.cz>
 *
 * $Id: IscsiServer.ycp 23442 2005-05-18 07:46:28Z visnov $
 *
 * Representation of the configuration of iscsi-server.
 * Input and output routines.
 */

{

module "IscsiServer";
textdomain "iscsi-server";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Service";
import "Package";
import "Popup";

map <string, any> config_file = $[];
global map<string, any> config = $[];
global list<map<string, any> > auth = [];

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

// Settings: Define all variables needed for configuration of iscsi-server
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//   boolean additional_parameter = true;

boolean readConfig(){
 config_file = (map<string, any>)SCR::Read(.etc.ietd.all);
 string c_scope="";
 foreach(map<string, any> row, config_file["value"]:[], {
  if (size(c_scope)==0 && ( row["name"]:"" == "IncomingUser" || row["name"]:"" == "OutgoingUser" ))
				auth = add(auth, $["KEY":row["name"]:"", "VALUE":row["value"]:""]);
   else if (row["name"]:"" == "Target") {
			c_scope = row["value"]:"";
			config[c_scope] = [ $[ "KEY":"Target", "VALUE":row["value"]:"" ] ];
			}
	else config[c_scope] = add(config[c_scope]:[], $[ "KEY":row["name"]:"", "VALUE":row["value"]:"" ]);
 });
y2internal("auth %1", auth);
 return true;
}

boolean find_in(map<string, any> my_conf, string to_find){
 boolean ret = false;
 foreach(string key, any value, my_conf, {
  if ( key == to_find ) ret = true;
 });
 return ret;
}

map<string, any> create_map(map<string, any> old_map)
{
 y2internal("old map %1", old_map);
 return $[ "name":old_map["KEY"]:"",
           "value":old_map["VALUE"]:"",
           "kind":"value",
           "type":1,
           "comment":""
         ];
}

boolean writeConfig(){

 string c_scope = "";
 list <map<string, any> > tmp2_config = [];
 list <string> used_scopes = [];
 list <map<string, any> > need_keys = [];

y2internal("auth %1", auth);

 foreach(map<string, any> row, config_file["value"]:[], {

  if ( c_scope=="" && row["name"]:"" != "Target" ) {
   if (size(auth)>0){
y2internal("%1", row);
 /*
    row["name"] = auth["KEY"]:"";
    row["value"] = auth["VALUE"]:"";
    tmp2_config = add(tmp2_config, row);
*/
   }
  } else
     if (row["name"]:"" == "Target"){
/*
	if (size(auth)>0 && size(tmp2_config)==0){
	 row["name"] = auth["KEY"]:"";
	 row["value"] = auth["VALUE"]:"";
	 tmp2_config = add(tmp2_config, row);
	}
*/
      need_keys = maplist(map<string, any> my_map, need_keys, { return create_map(my_map);});
      tmp2_config = (list<map<string, any> >)flatten([ tmp2_config, need_keys ]);
      c_scope  = row["value"]:"";
      used_scopes = add( used_scopes, c_scope );
    need_keys = config[c_scope]:[];
     } else
	{
	 list <string> used_keys = [];
	 foreach(map<string, any> m, config[c_scope]:[], {
	 if (m["KEY"]:"" == row["name"]:"") {
	   row["value"] = m["VALUE"]:"";
	  }
	   used_keys = add(used_keys, m["KEY"]:"");
	 });
	 if ((find_in(config, c_scope)) && (contains(used_keys, row["name"]:""))) {
							}
	}
 });

 need_keys = maplist(map<string, any> my_map, need_keys, { return create_map(my_map);});
 tmp2_config = (list<map<string, any> >)flatten([ tmp2_config, need_keys ]);
y2internal("tmp2_config %1", tmp2_config);

 foreach(string key, any value, config, {
  if (!contains(used_scopes, key)){
	list <map<string, any> > tmp1_config = [];
	foreach(map<string, any>  row, config[key]:[], {
	 tmp1_config = add( tmp1_config, create_map(row) );
	});
	tmp2_config = (list<map<string, any> >)flatten([ tmp2_config, tmp1_config ]);
       }
 });
 config_file["value"] = tmp2_config;
 y2internal("final write %1", tmp2_config);

// SCR::Write(.etc.ietd.all, config_file);
 return true;
}


boolean installed_packages(){
 boolean ret = false;
  if( !Package::InstallMsg( "iscsitarget",
            _("<p>To configure the SLP server, the <b>%1</b> packages must be installed.</p>") +
            _("<p>Do you want to install it now?</p>")) )
        {
        Popup::Error( Message::CannotContinueWithoutPackagesInstalled() );
    } else ret = true;

 return ret;
}


/**
 * Read all iscsi-server settings
 * @return true on success
 */
global boolean Read() {

    /* IscsiServer read dialog caption */
    string caption = _("Initializing iSCSI Server Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the database"),
	    /* Progress stage 2/3 */
	    _("Read the previous settings"),
	    /* Progress stage 3/3 */
	    _("Detect the devices")
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress step 2/3 */
	    _("Reading the previous settings..."),
	    /* Progress step 3/3 */
	    _("Detecting the devices..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(readConfig()==false) Report::Error(_("Cannot read database1."));
    sleep(sl);

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(false) Report::Error(_("Cannot read database2."));
    sleep(sl);

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(Message::CannotReadCurrentSettings());
    sleep(sl);

    // detect devices
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!installed_packages()) return false;
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all iscsi-server settings
 * @return true on success
 */
global boolean Write() {

    /* IscsiServer read dialog caption */
    string caption = _("Saving iSCSI Server Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(writeConfig()==false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(false) Report::Error (Message::SuSEConfigFailed());
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all iscsi-server settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the iscsi-server settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

global boolean GetStartService() {

 return Service::Enabled("iscsitarget");
}

global void SetStartService(boolean status) {
 y2milestone("Set service status %1", status);
 if (status == true) Service::Enable("iscsitarget");
        else Service::Disable("iscsitarget");
}


/* EOF */
}
